import { Page } from 'playwright';
import { Logger } from '../lib/Logger';
import z from 'zod';
import { Notifier } from '../lib/Notifier';
import { FileStreamer } from '../lib/FileStreamer';
import path from 'path';

const CaptionFragmentSchema = z.object({
    participant: z.object({
        name: z.string(),
    }),
    text: z.string(),
    started_at: z.object({
        absolute_timestamp: z.string().datetime(),
    }),
});

const CaptionsProcedureStateSchema = z.object({
    /** The bot ID */
    botId: z.string().uuid(),

    /** The status changes of the procedure */
    statusChanges: z.array(
        z.object({
            status: z.enum([
                'unknown',
                'initializing',
                'enabled',
                'subscribed',
                'fatal'
            ]),
            subCode: z.string().nullable(),
            message: z.string().nullable(),
            createdAt: z.string().datetime(),
        })
    ),

    /** The captions generated by the bot */
    captions: z.array(CaptionFragmentSchema),
})
type CaptionsProcedureStateType = z.infer<typeof CaptionsProcedureStateSchema>;

/**
 * CaptionsProcedure is a class that handles the captions flow for the bot.
 * There are two flows:
 * 1. Enable captions
 * 2. Subscribe to captions
 * 
 * The enable captions flow is used to enable the captions for the bot.
 * The subscribe to captions flow is used to subscribe to the captions for the bot.
 * Subscribing to captions also logs the caption and sends it to a separate server.
 */
export class CaptionsProcedure {
    private readonly page: Page;
    private readonly logger: Logger;
    private readonly transcriptFileStreamer: FileStreamer;
    private readonly notifier: Notifier | null = null;
    public state: CaptionsProcedureStateType;

    constructor(args: { botId: string, page: Page, notifierUrls?: string[] }) {
        this.page = args.page;
        this.state = CaptionsProcedureStateSchema.parse({
            botId: args.botId,
            statusChanges: [{
                status: 'initializing',
                subCode: null,
                message: null,
                createdAt: new Date().toISOString()
            }],
            captions: [],
        });
        this.logger = new Logger({ source: 'captions-procedure', botId: args.botId });
        this.transcriptFileStreamer = new FileStreamer({
            streamId: `${args.botId}-transcript`,
            filePath: path.join('output', 'transcripts', `${new Date().toISOString()}-${args.botId}.jsonl`)
        });

        if (args.notifierUrls && args.notifierUrls.length > 0) {
            this.notifier = new Notifier({ urls: args.notifierUrls, botId: this.state.botId });
        } else {
            this.logger.info({ message: 'No notifier URLs provided, will not send captions to webhook or websocket' });
        }
    }

    /** Helper method to add a status change to the procedure state */
    private _addStatusChange(statusChange: Partial<Omit<CaptionsProcedureStateType['statusChanges'][number], 'createdAt'>>) {
        this.state = CaptionsProcedureStateSchema.parse({
            ...this.state,
            statusChanges: [
                ...this.state.statusChanges,
                {
                    // Prefill/override the status, subCode and message from the status change
                    status: 'unknown' as const,
                    subCode: null,
                    message: null,
                    ...statusChange,
                    // Don't override the createdAt
                    createdAt: new Date().toISOString()
                }
            ].sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime())
        });
    }

    /**
     * ================================================
     * Public methods
     * ================================================
     */

    /** Enables the captions flow via the UI */
    public async enableCaptionsFlow() {
        try {
            this.logger.info({ message: 'Starting captions procedure.' });

            // Open the "More" menu
            const moreButtonSelector = 'button[id="callingButtons-showMoreBtn"]';
            await this.page.waitForSelector(moreButtonSelector, { timeout: 120000 });
            this.logger.info({ message: 'Found "More" button.' });
            await this.page.click(moreButtonSelector);
            this.logger.info({ message: 'Clicked "More" button.' });

            // Select the "Captions" button
            const turnOnCaptionsButtonSelector = 'div[id="closed-captions-button"]';
            await this.page.waitForSelector(turnOnCaptionsButtonSelector, { timeout: 120000 });
            this.logger.info({ message: 'Found "Captions" button.' });
            await this.page.click(turnOnCaptionsButtonSelector);
            this.logger.info({ message: 'Clicked "Captions" button.' });

            // Wait for the captions container to be visible
            const captionsContainerSelector = 'div[data-tid="closed-caption-renderer-wrapper"]';
            await this.page.waitForSelector(captionsContainerSelector, { timeout: 120000 });
            this.logger.info({ message: 'Found captions container.' });

            this._addStatusChange({ status: 'enabled', subCode: null, message: 'Live captions enabled' });
        } catch (error) {
            this._addStatusChange({ status: 'fatal', subCode: 'captions_error', message: 'Error enabling captions' });
            this.logger.error({ message: 'Error enabling captions', data: error });
            throw error;
        }
    }

    /** Subscribes to the captions if the captions are enabled */
    public async subscribeToCaptions() {
        /** Helper function to handle new caption events */
        const onCaption = (newCaption: z.input<typeof CaptionFragmentSchema>) => {
            // Teams will only add punctuation to finalized meeting captions.
            // This means we can flush the caption if it contains punctuation.
            const terminalPunctuationRegex = /[.,!]/g;
            if (!terminalPunctuationRegex.test(newCaption.text)) {
                return;
            }

            // To dedup captions that have punctuation without finalizing (e.g. "I spent $500.00 today"),
            // we strip all punctuation from the new caption and the latest caption and see if they are the same.
            const punctuationRegex = /[.,'"!~-]/g;
            const newCaptionText = newCaption.text.replace(punctuationRegex, '');
            const latestCaptionText = this.state.captions[this.state.captions.length - 1]?.text.replace(punctuationRegex, '');
            if (newCaptionText === latestCaptionText) {
                this.logger.info({ message: 'Skipping caption event because it is the same as the latest caption', data: newCaption });
                return;
            }

            // Add the new caption to the state
            this.state = CaptionsProcedureStateSchema.parse({ ...this.state, captions: [...this.state.captions, newCaption] });

            // Write caption to console/logfile
            this.logger.info({ message: `Detected caption event: ${newCaption.participant.name} said: "${newCaption.text}"` });

            // Write caption to file
            this.transcriptFileStreamer.write(newCaption);

            // Send the caption to the webhook
            if (this.notifier) {
                this.notifier.sendEventToServer({
                    payload: {
                        event: 'captions.data',
                        data: {
                            botId: this.state.botId,
                            captionFragment: newCaption
                        }
                    }
                });
            }
        }

        try {
            // Add a onNewCaption function to the window object
            await this.page.exposeFunction('onCaption', onCaption);

            // Check if the captions are enabled
            const captionsContainerSelector = 'div[data-tid="closed-caption-renderer-wrapper"]';
            await this.page.waitForSelector(captionsContainerSelector, { timeout: 120000 });

            this.logger.info({ message: 'Subscribing to captions.' });

            await this.page.evaluate(() => {
                const targetNode = document.querySelector('div[data-tid="closed-caption-renderer-wrapper"]');
                if (!targetNode) {
                    return;
                }

                const observer = new MutationObserver((mutationsList) => {
                    for (const mutation of mutationsList) {
                        if (mutation.type === 'childList') {
                            mutation.addedNodes.forEach((node) => {
                                if (node.nodeType === Node.ELEMENT_NODE) {
                                    const element = node as HTMLElement;

                                    // Check if this is a caption element
                                    const captionMessage = element.querySelector('.fui-ChatMessageCompact');
                                    if (!captionMessage) {
                                        return;
                                    }

                                    const authorElement = captionMessage.querySelector('span[data-tid="author"]');
                                    const contentElement = captionMessage.querySelector('span[data-tid="closed-caption-text"]');

                                    if (authorElement && contentElement) {
                                        // Captions will update in real time as the user speaks.
                                        // Therefore we create a new MutationObserver to watch for changes in the contentElement's innerText.
                                        const textObserver = new MutationObserver(() => {
                                            const name = authorElement.textContent?.trim() ?? 'Unknown';
                                            const text = (contentElement as any).innerText?.trim() ?? '';

                                            (window as any).onCaption({
                                                participant: { name },
                                                text,
                                                started_at: {
                                                    absolute_timestamp: new Date().toISOString(),
                                                },
                                            });
                                        });

                                        textObserver.observe(contentElement, {
                                            childList: true,
                                            subtree: true,
                                            characterData: true,
                                        });
                                    }
                                }
                            });
                        }
                    }
                });

                observer.observe(targetNode, { childList: true, subtree: true });
            });

            this._addStatusChange({ status: 'subscribed', message: 'Subscribed to captions' });
        } catch (error) {
            this._addStatusChange({ status: 'fatal', subCode: 'captions_error', message: 'Error subscribing to captions' });
            this.logger.error({ message: 'Error subscribing to captions', data: error });
            throw error;
        }
    }
} 